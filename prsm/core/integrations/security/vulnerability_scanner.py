"""
Vulnerability Scanner
====================

Security vulnerability scanner for external content, detecting
potential security issues before integration into PRSM.
"""

from datetime import datetime, timezone
from typing import Dict, List, Optional, Any
from uuid import UUID, uuid4

from ..models.integration_models import SecurityRisk


class VulnerabilityResult:
    """Result from vulnerability scanning operation"""
    
    def __init__(self, vulnerabilities: List[str], risk_level: SecurityRisk,
                 scan_method: str, details: Dict[str, Any]):
        self.vulnerabilities = vulnerabilities
        self.risk_level = risk_level
        self.scan_method = scan_method
        self.details = details
        self.scan_time = datetime.now(timezone.utc)


class VulnerabilityScanner:
    """
    Security vulnerability scanner for external content
    """
    
    def __init__(self):
        """Initialize vulnerability scanner"""
        
        # Vulnerability patterns
        self.vulnerability_patterns = {
            "sql_injection": {
                "patterns": [
                    r"SELECT.*FROM.*WHERE.*=.*input",
                    r"exec.*SELECT",
                    r"query.*\+.*user",
                    r"sql.*\+.*request"
                ],
                "severity": "high"
            },
            "xss": {
                "patterns": [
                    r"innerHTML.*=.*input",
                    r"document\.write.*input",
                    r"eval.*input",
                    r"outerHTML.*request"
                ],
                "severity": "medium"
            },
            "command_injection": {
                "patterns": [
                    r"system.*input",
                    r"exec.*input", 
                    r"shell_exec",
                    r"subprocess.*shell.*True"
                ],
                "severity": "critical"
            },
            "path_traversal": {
                "patterns": [
                    r"\.\./",
                    r"\.\.\\\\",
                    r"path.*input.*file",
                    r"open.*request.*path"
                ],
                "severity": "medium"
            },
            "hardcoded_secrets": {
                "patterns": [
                    r"password.*=.*['\"][^'\"]{8,}['\"]",
                    r"api_key.*=.*['\"][^'\"]{20,}['\"]",
                    r"secret.*=.*['\"][^'\"]{10,}['\"]",
                    r"token.*=.*['\"][^'\"]{20,}['\"]"
                ],
                "severity": "high"
            },
            "unsafe_deserialization": {
                "patterns": [
                    r"pickle\.loads",
                    r"yaml\.load\(",
                    r"eval\(",
                    r"exec\("
                ],
                "severity": "high"
            }
        }
        
        print("ðŸ” Vulnerability Scanner initialized")
    
    async def scan_vulnerabilities(self, content_path: str, 
                                 metadata: Dict[str, Any]) -> VulnerabilityResult:
        """
        Scan content for security vulnerabilities
        
        Args:
            content_path: Path to content to scan
            metadata: Content metadata
            
        Returns:
            VulnerabilityResult with vulnerability assessment
        """
        vulnerabilities = []
        details = {"patterns_checked": 0, "files_scanned": 0}
        
        try:
            # Pattern-based vulnerability scanning
            pattern_vulns = await self._pattern_based_scan(content_path)
            vulnerabilities.extend(pattern_vulns["vulnerabilities"])
            details.update(pattern_vulns["details"])
            
            # Determine risk level
            risk_level = self._assess_risk_level(vulnerabilities)
            
            return VulnerabilityResult(
                vulnerabilities=vulnerabilities,
                risk_level=risk_level,
                scan_method="pattern_based",
                details=details
            )
            
        except Exception as e:
            return VulnerabilityResult(
                vulnerabilities=[f"Scan error: {str(e)}"],
                risk_level=SecurityRisk.HIGH,
                scan_method="error",
                details={"error": str(e)}
            )
    
    async def _pattern_based_scan(self, content_path: str) -> Dict[str, Any]:
        """Pattern-based vulnerability detection"""
        import re
        import os
        
        vulnerabilities = []
        details = {"patterns_checked": 0, "files_scanned": 0}
        
        try:
            if os.path.isfile(content_path):
                # Single file scan
                file_vulns = await self._scan_file(content_path)
                vulnerabilities.extend(file_vulns)
                details["files_scanned"] = 1
                
            elif os.path.isdir(content_path):
                # Directory scan
                for root, dirs, files in os.walk(content_path):
                    for file in files:
                        if self._should_scan_file(file):
                            file_path = os.path.join(root, file)
                            file_vulns = await self._scan_file(file_path)
                            vulnerabilities.extend(file_vulns)
                            details["files_scanned"] += 1
            
            details["patterns_checked"] = len(self.vulnerability_patterns)
            
            return {
                "vulnerabilities": vulnerabilities,
                "details": details
            }
            
        except Exception as e:
            return {
                "vulnerabilities": [f"Pattern scan error: {str(e)}"],
                "details": details
            }
    
    async def _scan_file(self, file_path: str) -> List[str]:
        """Scan individual file for vulnerabilities"""
        import re
        
        vulnerabilities = []
        
        try:
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read(50000)  # Read first 50KB
                
                # Check each vulnerability pattern
                for vuln_type, vuln_info in self.vulnerability_patterns.items():
                    for pattern in vuln_info["patterns"]:
                        matches = re.findall(pattern, content, re.IGNORECASE)
                        if matches:
                            severity = vuln_info["severity"]
                            vuln_desc = f"{severity.upper()}: {vuln_type.replace('_', ' ')} in {os.path.basename(file_path)}"
                            vulnerabilities.append(vuln_desc)
                            break  # Only report once per vulnerability type per file
                            
        except Exception:
            # Ignore file reading errors
            pass
        
        return vulnerabilities
    
    def _should_scan_file(self, filename: str) -> bool:
        """Determine if file should be scanned for vulnerabilities"""
        scannable_extensions = [
            '.py', '.js', '.ts', '.java', '.cpp', '.c', '.cs', '.php',
            '.rb', '.go', '.rs', '.swift', '.kt', '.scala', '.sh', '.ps1'
        ]
        
        return any(filename.lower().endswith(ext) for ext in scannable_extensions)
    
    def _assess_risk_level(self, vulnerabilities: List[str]) -> SecurityRisk:
        """Assess overall risk level based on vulnerabilities found"""
        if not vulnerabilities:
            return SecurityRisk.NONE
        
        # Count vulnerabilities by severity
        critical_count = sum(1 for v in vulnerabilities if "CRITICAL:" in v)
        high_count = sum(1 for v in vulnerabilities if "HIGH:" in v)
        medium_count = sum(1 for v in vulnerabilities if "MEDIUM:" in v)
        
        # Determine risk level
        if critical_count > 0:
            return SecurityRisk.CRITICAL
        elif high_count > 2:
            return SecurityRisk.HIGH
        elif high_count > 0 or medium_count > 3:
            return SecurityRisk.MEDIUM
        elif medium_count > 0:
            return SecurityRisk.LOW
        else:
            return SecurityRisk.LOW