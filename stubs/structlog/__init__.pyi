"""
Type stubs for structlog
========================

Provides type annotations for the structlog library to support
static type checking in the PRSM codebase.
"""

from typing import Any, Dict, Optional, Union, Callable, Protocol, TypeVar
from types import TracebackType
import logging

# Type variables
F = TypeVar('F', bound=Callable[..., Any])
LoggerType = TypeVar('LoggerType')

class FilteringBoundLogger:
    """Bound logger with filtering capabilities"""
    def debug(self, event: str = ..., **kw: Any) -> Any: ...
    def info(self, event: str = ..., **kw: Any) -> Any: ...
    def warning(self, event: str = ..., **kw: Any) -> Any: ...
    def warn(self, event: str = ..., **kw: Any) -> Any: ...
    def error(self, event: str = ..., **kw: Any) -> Any: ...
    def critical(self, event: str = ..., **kw: Any) -> Any: ...
    def exception(self, event: str = ..., **kw: Any) -> Any: ...
    def bind(self, **new_values: Any) -> FilteringBoundLogger: ...
    def new(self, **new_values: Any) -> FilteringBoundLogger: ...
    def unbind(self, *keys: str) -> FilteringBoundLogger: ...

class BoundLoggerLazyProxy:
    """Lazy proxy for bound loggers"""
    def debug(self, event: str = ..., **kw: Any) -> Any: ...
    def info(self, event: str = ..., **kw: Any) -> Any: ...
    def warning(self, event: str = ..., **kw: Any) -> Any: ...
    def warn(self, event: str = ..., **kw: Any) -> Any: ...
    def error(self, event: str = ..., **kw: Any) -> Any: ...
    def critical(self, event: str = ..., **kw: Any) -> Any: ...
    def exception(self, event: str = ..., **kw: Any) -> Any: ...
    def bind(self, **new_values: Any) -> BoundLoggerLazyProxy: ...
    def new(self, **new_values: Any) -> BoundLoggerLazyProxy: ...
    def unbind(self, *keys: str) -> BoundLoggerLazyProxy: ...

# Processor types
class Processor(Protocol):
    def __call__(self, logger: Any, method_name: str, event_dict: Dict[str, Any]) -> Dict[str, Any]: ...

class KeyValueRenderer:
    def __init__(
        self,
        key_order: Optional[list[str]] = ...,
        drop_missing: bool = ...,
        sort_keys: bool = ...
    ) -> None: ...
    def __call__(self, logger: Any, method_name: str, event_dict: Dict[str, Any]) -> str: ...

class JSONRenderer:
    def __init__(self, **dumps_kw: Any) -> None: ...
    def __call__(self, logger: Any, method_name: str, event_dict: Dict[str, Any]) -> str: ...

def add_log_level(logger: Any, method_name: str, event_dict: Dict[str, Any]) -> Dict[str, Any]: ...
def add_logger_name(logger: Any, method_name: str, event_dict: Dict[str, Any]) -> Dict[str, Any]: ...

class TimeStamper:
    def __init__(
        self,
        fmt: Optional[str] = ...,
        utc: bool = ...,
        key: str = ...
    ) -> None: ...
    def __call__(self, logger: Any, method_name: str, event_dict: Dict[str, Any]) -> Dict[str, Any]: ...

def format_exc_info(logger: Any, method_name: str, event_dict: Dict[str, Any]) -> Dict[str, Any]: ...

# Configuration functions
def configure(
    processors: Optional[list[Processor]] = ...,
    wrapper_class: Optional[type] = ...,
    logger_factory: Optional[Callable[..., Any]] = ...,
    context_class: Optional[type] = ...,
    cache_logger_on_first_use: bool = ...
) -> None: ...

def configure_once(
    processors: Optional[list[Processor]] = ...,
    wrapper_class: Optional[type] = ...,
    logger_factory: Optional[Callable[..., Any]] = ...,
    context_class: Optional[type] = ...,
    cache_logger_on_first_use: bool = ...
) -> None: ...

def get_logger(name: Optional[str] = ...) -> FilteringBoundLogger: ...

def wrap_logger(
    logger: Any,
    processors: Optional[list[Processor]] = ...,
    wrapper_class: Optional[type] = ...,
    context: Optional[Dict[str, Any]] = ...
) -> FilteringBoundLogger: ...

# Standard library integration
class LoggerFactory:
    def __init__(self, ignore_frame_names: Optional[list[str]] = ...) -> None: ...
    def __call__(self, name: str) -> logging.Logger: ...

def get_context() -> Dict[str, Any]: ...
def clear_context() -> None: ...
def bind_context(**kw: Any) -> None: ...
def unbind_context(*keys: str) -> None: ...

# Testing utilities  
class testing:
    @staticmethod
    def capture_logs() -> Any: ...

# Backward compatibility
PrintLogger = FilteringBoundLogger
PrintLoggerFactory = LoggerFactory