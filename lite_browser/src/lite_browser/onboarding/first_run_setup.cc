// First Run Setup Implementation
#include "lite_browser/onboarding/first_run_setup.h"

#include <iostream>
#include <fstream>
#include <sstream>
#include <regex>
#include <chrono>
#include <iomanip>
#include <filesystem>

namespace lite_browser {

FirstRunSetup::FirstRunSetup() : debug_mode_(true) {
    // Set configuration file path
    std::string home_dir = std::getenv("HOME") ? std::getenv("HOME") : ".";
    config_file_path_ = home_dir + "/.config/lite_browser/config.json";
    
    // Ensure config directory exists
    std::filesystem::create_directories(home_dir + "/.config/lite_browser");
}

FirstRunSetup::~FirstRunSetup() = default;

bool FirstRunSetup::RunFirstTimeSetup() {
    std::cout << "\n🎉 Welcome to LITE Browser First-Time Setup!" << std::endl;
    std::cout << "💡 Linked Information Transfer Engine" << std::endl;
    std::cout << "🔬 Native P2P Research Collaboration Browser\n" << std::endl;
    
    if (!WelcomeAndIntroduction()) {
        return false;
    }
    
    OnboardingConfig config = {};
    
    // Step 1: User Profile
    std::cout << "\n" << std::string(60, '=') << std::endl;
    std::cout << "👤 STEP 1: User Profile Setup" << std::endl;
    std::cout << std::string(60, '=') << std::endl;
    
    if (!CollectUserProfile(config.user_profile)) {
        std::cout << "❌ Profile setup failed. Exiting setup." << std::endl;
        return false;
    }
    
    // Step 2: Compute Contribution
    std::cout << "\n" << std::string(60, '=') << std::endl;
    std::cout << "💻 STEP 2: Compute & Storage Contribution" << std::endl;
    std::cout << std::string(60, '=') << std::endl;
    
    if (!ConfigureComputeContribution(config.compute_settings)) {
        std::cout << "❌ Compute configuration failed. Exiting setup." << std::endl;
        return false;
    }
    
    // Step 3: FTNS Configuration
    std::cout << "\n" << std::string(60, '=') << std::endl;
    std::cout << "🪙 STEP 3: FTNS Token Earning Setup" << std::endl;
    std::cout << std::string(60, '=') << std::endl;
    
    if (!ConfigureFTNSSettings(config.ftns_settings)) {
        std::cout << "❌ FTNS configuration failed. Exiting setup." << std::endl;
        return false;
    }
    
    // Step 4: Network Settings
    std::cout << "\n" << std::string(60, '=') << std::endl;
    std::cout << "🌐 STEP 4: Network Configuration" << std::endl;
    std::cout << std::string(60, '=') << std::endl;
    
    if (!ConfigureNetworkSettings(config.network_settings)) {
        std::cout << "❌ Network configuration failed. Exiting setup." << std::endl;
        return false;
    }
    
    // Step 5: Security Settings
    std::cout << "\n" << std::string(60, '=') << std::endl;
    std::cout << "🔐 STEP 5: Security Configuration" << std::endl;
    std::cout << std::string(60, '=') << std::endl;
    
    if (!ConfigureSecuritySettings(config.security_settings)) {
        std::cout << "❌ Security configuration failed. Exiting setup." << std::endl;
        return false;
    }
    
    // Finalize setup
    std::cout << "\n" << std::string(60, '=') << std::endl;
    std::cout << "✅ STEP 6: Finalizing Setup" << std::endl;
    std::cout << std::string(60, '=') << std::endl;
    
    return FinalizeSetup(config);
}

bool FirstRunSetup::WelcomeAndIntroduction() {
    DisplayWelcomeMessage();
    
    if (!PromptYesNo("Ready to begin setup?", true)) {
        std::cout << "Setup cancelled. You can run 'lite_browser --setup' anytime." << std::endl;
        return false;
    }
    
    return true;
}

bool FirstRunSetup::CollectUserProfile(UserProfile& profile) {
    std::cout << "📋 Let's set up your research profile...\n" << std::endl;
    
    // Basic information
    profile.full_name = PromptUserInput("Full Name");
    profile.email = PromptUserInput("Email Address");
    
    if (!ValidateEmail(profile.email)) {
        std::cout << "❌ Invalid email format. Please restart setup." << std::endl;
        return false;
    }
    
    // Extract institution domain from email
    size_t at_pos = profile.email.find('@');\n    if (at_pos != std::string::npos) {\n        profile.institution_domain = profile.email.substr(at_pos + 1);\n    }\n    \n    // Verify institutional affiliation\n    if (!VerifyInstitutionalAffiliation(profile.email, profile.institution_domain)) {\n        std::cout << \"⚠️  Warning: Could not verify institutional affiliation.\" << std::endl;\n        if (!PromptYesNo(\"Continue anyway?\", false)) {\n            return false;\n        }\n    }\n    \n    profile.institution = PromptUserInput(\"Institution Name (e.g., University of North Carolina)\");\n    profile.department = PromptUserInput(\"Department\", false);\n    profile.academic_title = PromptUserInput(\"Academic Title (e.g., Graduate Student, Professor)\", false);\n    profile.orcid_id = PromptUserInput(\"ORCID ID (optional)\", false);\n    \n    // Research areas\n    std::cout << \"\\n🔬 Research Areas (select all that apply):\" << std::endl;\n    std::vector<std::string> research_options = {\n        \"Computer Science\", \"Physics\", \"Chemistry\", \"Biology\", \"Mathematics\", \n        \"Engineering\", \"Medicine\", \"Social Sciences\", \"Economics\", \"Psychology\",\n        \"Quantum Computing\", \"Artificial Intelligence\", \"Machine Learning\", \n        \"Data Science\", \"Materials Science\", \"Environmental Science\", \"Other\"\n    };\n    \n    profile.research_areas = PromptMultiSelect(\"Select research areas\", research_options);\n    \n    // Collaboration preferences\n    std::cout << \"\\n🤝 Collaboration Preferences:\" << std::endl;\n    profile.allow_industry_collaboration = PromptYesNo(\"Allow collaboration with industry partners?\", false);\n    profile.require_multi_sig_approval = PromptYesNo(\"Require approval for sensitive collaborations?\", true);\n    profile.auto_accept_institutional_invites = PromptYesNo(\"Auto-accept invites from your institution?\", true);\n    \n    std::cout << \"\\n✅ Profile setup complete!\" << std::endl;\n    std::cout << \"   Name: \" << profile.full_name << std::endl;\n    std::cout << \"   Institution: \" << profile.institution << std::endl;\n    std::cout << \"   Research areas: \" << profile.research_areas.size() << \" selected\" << std::endl;\n    \n    return true;\n}\n\nbool FirstRunSetup::ConfigureComputeContribution(ComputeContribution& compute) {\n    std::cout << \"💰 Earn FTNS tokens by contributing your compute resources!\\n\" << std::endl;\n    \n    compute.enabled = PromptYesNo(\"Enable compute contribution to earn FTNS tokens?\", true);\n    \n    if (!compute.enabled) {\n        std::cout << \"ℹ️  You can enable this later in settings.\" << std::endl;\n        return true;\n    }\n    \n    std::cout << \"\\n🔧 Resource Allocation:\" << std::endl;\n    \n    // CPU usage\n    std::cout << \"CPU: How much CPU should LITE use for contribution tasks?\" << std::endl;\n    std::cout << \"  • 10-25%: Light contribution, minimal impact\" << std::endl;\n    std::cout << \"  • 25-50%: Moderate contribution, noticeable during heavy tasks\" << std::endl;\n    std::cout << \"  • 50-75%: Heavy contribution, may slow other applications\" << std::endl;\n    compute.max_cpu_usage_percent = PromptInteger(\"Max CPU usage %\", 10, 75, 25);\n    \n    // Storage\n    std::cout << \"\\nStorage: How much storage should LITE use for distributed files?\" << std::endl;\n    compute.max_storage_gb = PromptInteger(\"Max storage (GB)\", 1, 1000, 10);\n    \n    // Bandwidth\n    std::cout << \"\\nBandwidth: How much bandwidth for P2P file sharing?\" << std::endl;\n    compute.max_bandwidth_mbps = PromptInteger(\"Max bandwidth (Mbps)\", 1, 100, 10);\n    \n    // Contribution preferences\n    std::cout << \"\\n⚙️  Contribution Preferences:\" << std::endl;\n    compute.contribute_during_idle_only = PromptYesNo(\"Only contribute when computer is idle?\", true);\n    compute.exclude_sensitive_files = PromptYesNo(\"Exclude sensitive research files from sharing?\", true);\n    compute.allow_ml_training = PromptYesNo(\"Allow ML model training tasks?\", false);\n    compute.allow_data_processing = PromptYesNo(\"Allow data processing tasks?\", true);\n    \n    // Contribution types\n    std::vector<std::string> contribution_options = {\"storage\", \"compute\", \"bandwidth\"};\n    compute.contribution_types = PromptMultiSelect(\"Contribution types\", contribution_options);\n    \n    // Display earnings estimate\n    int estimated_monthly = EstimateMonthlyFTNSEarnings(compute);\n    std::cout << \"\\n💰 Estimated Monthly Earnings: ~\" << estimated_monthly << \" FTNS tokens\" << std::endl;\n    std::cout << GetResourceUsageSummary(compute) << std::endl;\n    \n    return true;\n}\n\nbool FirstRunSetup::ConfigureFTNSSettings(FTNSConfiguration& ftns) {\n    DisplayFTNSInformation();\n    \n    ftns.auto_earn_enabled = PromptYesNo(\"Enable automatic FTNS earning?\", true);\n    \n    if (!ftns.auto_earn_enabled) {\n        std::cout << \"ℹ️  You can enable FTNS earning later in settings.\" << std::endl;\n        return true;\n    }\n    \n    std::cout << \"\\n💳 FTNS Configuration:\" << std::endl;\n    \n    // Payout settings\n    ftns.minimum_payout_threshold = PromptInteger(\"Minimum FTNS before payout\", 10, 1000, 100);\n    ftns.payout_address = PromptUserInput(\"Wallet address for payouts (leave empty for institutional default)\", false);\n    \n    // Earning preferences\n    ftns.prioritize_research_tasks = PromptYesNo(\"Prioritize research tasks over commercial tasks?\", true);\n    ftns.accept_industry_compute_tasks = PromptYesNo(\"Accept compute tasks from industry partners?\", false);\n    ftns.institutional_validation_required = PromptYesNo(\"Require institutional validation for high-value tasks?\", true);\n    \n    // Minimum rates\n    std::cout << \"\\nMinimum hourly rate for compute tasks (FTNS/hour):\" << std::endl;\n    std::cout << \"  • 0.1-1.0: Accept most tasks\" << std::endl;\n    std::cout << \"  • 1.0-5.0: Moderate selectivity\" << std::endl;\n    std::cout << \"  • 5.0+: Only high-value tasks\" << std::endl;\n    \n    std::string rate_str = PromptUserInput(\"Minimum rate (default: 1.0)\", false);\n    ftns.min_hourly_rate_ftns = rate_str.empty() ? 1.0 : std::stod(rate_str);\n    \n    std::vector<std::string> contrib_options = {\"storage\", \"compute\", \"bandwidth\", \"research_validation\"};\n    ftns.preferred_contribution_types = PromptMultiSelect(\"Preferred earning methods\", contrib_options);\n    \n    return true;\n}\n\nbool FirstRunSetup::ConfigureNetworkSettings(NetworkSettings& network) {\n    std::cout << \"🌐 Network configuration for P2P research collaboration...\\n\" << std::endl;\n    \n    network.enable_ipv6 = PromptYesNo(\"Enable IPv6 support?\", true);\n    network.max_peer_connections = PromptInteger(\"Maximum peer connections\", 10, 100, 50);\n    network.auto_discover_institutional_peers = PromptYesNo(\"Auto-discover peers from your institution?\", true);\n    network.restrict_to_academic_networks = PromptYesNo(\"Restrict connections to academic networks only?\", false);\n    \n    // Bootstrap nodes (use defaults)\n    network.bootstrap_nodes = {\"unc.edu:8445\", \"mit.edu:8445\", \"stanford.edu:8445\"};\n    \n    std::cout << \"✅ Network configured with \" << network.max_peer_connections \n              << \" max connections\" << std::endl;\n    \n    return true;\n}\n\nbool FirstRunSetup::ConfigureSecuritySettings(SecuritySettings& security) {\n    DisplaySecurityInformation();\n    \n    std::cout << \"\\n🔐 Security Level:\" << std::endl;\n    std::cout << \"  • Standard: Good for most research\" << std::endl;\n    std::cout << \"  • High: For sensitive research data\" << std::endl;\n    std::cout << \"  • Maximum: For classified/proprietary research\" << std::endl;\n    \n    std::string security_level = PromptUserInput(\"Security level (standard/high/maximum)\", true);\n    if (security_level != \"standard\" && security_level != \"high\" && security_level != \"maximum\") {\n        security_level = \"standard\";\n    }\n    security.encryption_level = security_level;\n    \n    // Configure based on security level\n    if (security_level == \"maximum\") {\n        security.post_quantum_enabled = true;\n        security.strict_certificate_validation = true;\n        security.encrypt_local_storage = true;\n        security.auto_update_trust_anchors = false; // Manual control for maximum security\n    } else if (security_level == \"high\") {\n        security.post_quantum_enabled = true;\n        security.strict_certificate_validation = true;\n        security.encrypt_local_storage = PromptYesNo(\"Encrypt local storage?\", true);\n        security.auto_update_trust_anchors = true;\n    } else {\n        security.post_quantum_enabled = PromptYesNo(\"Enable post-quantum cryptography?\", true);\n        security.strict_certificate_validation = true;\n        security.encrypt_local_storage = PromptYesNo(\"Encrypt local storage?\", false);\n        security.auto_update_trust_anchors = true;\n    }\n    \n    std::cout << \"✅ Security configured: \" << security_level << \" level\" << std::endl;\n    \n    return true;\n}\n\nbool FirstRunSetup::FinalizeSetup(const OnboardingConfig& config) {\n    DisplaySetupSummary(config);\n    \n    if (!PromptYesNo(\"Save configuration and complete setup?\", true)) {\n        std::cout << \"Setup cancelled. Configuration not saved.\" << std::endl;\n        return false;\n    }\n    \n    // Save configuration\n    if (!SaveConfiguration(config)) {\n        std::cout << \"❌ Failed to save configuration.\" << std::endl;\n        return false;\n    }\n    \n    std::cout << \"\\n🎉 Setup Complete!\" << std::endl;\n    std::cout << \"✅ LITE Browser is now configured and ready to use\" << std::endl;\n    std::cout << \"💰 FTNS earning is \" << (config.ftns_settings.auto_earn_enabled ? \"ENABLED\" : \"DISABLED\") << std::endl;\n    std::cout << \"🔒 Security level: \" << config.security_settings.encryption_level << std::endl;\n    \n    if (config.compute_settings.enabled) {\n        int monthly_estimate = EstimateMonthlyFTNSEarnings(config.compute_settings);\n        std::cout << \"💰 Estimated monthly earnings: ~\" << monthly_estimate << \" FTNS\" << std::endl;\n    }\n    \n    std::cout << \"\\n🚀 Starting LITE Browser...\" << std::endl;\n    \n    return true;\n}\n\n// Helper method implementations\nstd::string FirstRunSetup::PromptUserInput(const std::string& prompt, bool required) {\n    std::string input;\n    do {\n        std::cout << prompt << (required ? \" (required)\" : \" (optional)\") << \": \";\n        std::getline(std::cin, input);\n        \n        if (!required || !input.empty()) {\n            break;\n        }\n        std::cout << \"This field is required. Please enter a value.\" << std::endl;\n    } while (true);\n    \n    return input;\n}\n\nbool FirstRunSetup::PromptYesNo(const std::string& question, bool default_yes) {\n    std::string input;\n    std::cout << question << (default_yes ? \" (Y/n): \" : \" (y/N): \");\n    std::getline(std::cin, input);\n    \n    if (input.empty()) {\n        return default_yes;\n    }\n    \n    return (input[0] == 'y' || input[0] == 'Y');\n}\n\nint FirstRunSetup::PromptInteger(const std::string& prompt, int min_val, int max_val, int default_val) {\n    std::string input;\n    int value;\n    \n    do {\n        std::cout << prompt << \" (\" << min_val << \"-\" << max_val << \", default \" << default_val << \"): \";\n        std::getline(std::cin, input);\n        \n        if (input.empty()) {\n            return default_val;\n        }\n        \n        try {\n            value = std::stoi(input);\n            if (value >= min_val && value <= max_val) {\n                return value;\n            }\n            std::cout << \"Value must be between \" << min_val << \" and \" << max_val << std::endl;\n        } catch (const std::exception&) {\n            std::cout << \"Please enter a valid number.\" << std::endl;\n        }\n    } while (true);\n}\n\nstd::vector<std::string> FirstRunSetup::PromptMultiSelect(const std::string& prompt, \n                                                        const std::vector<std::string>& options) {\n    std::cout << \"\\n\" << prompt << \" (enter numbers separated by spaces):\" << std::endl;\n    \n    for (size_t i = 0; i < options.size(); ++i) {\n        std::cout << \"  \" << (i + 1) << \". \" << options[i] << std::endl;\n    }\n    \n    std::string input;\n    std::cout << \"Selection: \";\n    std::getline(std::cin, input);\n    \n    std::vector<std::string> selected;\n    std::istringstream iss(input);\n    std::string token;\n    \n    while (iss >> token) {\n        try {\n            int index = std::stoi(token) - 1;\n            if (index >= 0 && index < static_cast<int>(options.size())) {\n                selected.push_back(options[index]);\n            }\n        } catch (const std::exception&) {\n            // Ignore invalid input\n        }\n    }\n    \n    return selected;\n}\n\n// Display methods\nvoid FirstRunSetup::DisplayWelcomeMessage() {\n    std::cout << R\"(\n╔══════════════════════════════════════════════════════════════════════════════╗\n║                           🎉 Welcome to LITE Browser! 🎉                    ║\n║                    Linked Information Transfer Engine                        ║\n║                                                                              ║\n║  🔬 Revolutionary P2P Research Collaboration Browser                        ║\n║  💡 Native support for lite://, shard://, and collab:// protocols          ║\n║  🪙 Earn FTNS tokens by contributing compute resources                       ║\n║  🔒 Post-quantum cryptography for maximum security                          ║\n║  🤝 Seamless university-industry collaboration                               ║\n║                                                                              ║\n║  This setup will configure your profile, resource contribution,            ║\n║  and FTNS earning preferences. Takes about 5 minutes.                      ║\n╚══════════════════════════════════════════════════════════════════════════════╝\n    )\" << std::endl;\n}\n\nvoid FirstRunSetup::DisplayFTNSInformation() {\n    std::cout << R\"(\n💰 FTNS (Federated Token Network System) Information:\n\n• Earn tokens by contributing compute, storage, and bandwidth\n• Tokens can be used for:\n  - Premium research collaborations\n  - Priority access to distributed files\n  - Advanced AI-powered research tools\n  - Industry partnership opportunities\n\n• Typical earnings:\n  - Storage: 0.1-0.5 FTNS/GB/month\n  - Compute: 1-10 FTNS/hour (depending on task)\n  - Bandwidth: 0.01-0.1 FTNS/GB transferred\n\n• Institutional validation adds 25% bonus to earnings\n    )\" << std::endl;\n}\n\nvoid FirstRunSetup::DisplaySecurityInformation() {\n    std::cout << R\"(\n🔐 LITE Browser Security Features:\n\n• Post-Quantum Cryptography: Future-proof against quantum computers\n• Multi-Signature Workflows: Institutional approval for sensitive actions\n• Encrypted Local Storage: Protect your research data\n• Certificate Pinning: Prevent man-in-the-middle attacks\n• Zero-Knowledge Architecture: Your data stays private\n\n• All communications use end-to-end encryption\n• Regular security audits by university partners\n• GDPR and FERPA compliant\n    )\" << std::endl;\n}\n\nvoid FirstRunSetup::DisplaySetupSummary(const OnboardingConfig& config) {\n    std::cout << \"\\n\" << std::string(60, '=') << std::endl;\n    std::cout << \"📋 Setup Summary\" << std::endl;\n    std::cout << std::string(60, '=') << std::endl;\n    \n    std::cout << \"👤 Profile:\" << std::endl;\n    std::cout << \"   Name: \" << config.user_profile.full_name << std::endl;\n    std::cout << \"   Institution: \" << config.user_profile.institution << std::endl;\n    std::cout << \"   Research Areas: \" << config.user_profile.research_areas.size() << \" selected\" << std::endl;\n    \n    std::cout << \"\\n💻 Compute Contribution:\" << std::endl;\n    if (config.compute_settings.enabled) {\n        std::cout << \"   Status: ENABLED\" << std::endl;\n        std::cout << \"   CPU: \" << config.compute_settings.max_cpu_usage_percent << \"%\" << std::endl;\n        std::cout << \"   Storage: \" << config.compute_settings.max_storage_gb << \" GB\" << std::endl;\n        std::cout << \"   Bandwidth: \" << config.compute_settings.max_bandwidth_mbps << \" Mbps\" << std::endl;\n    } else {\n        std::cout << \"   Status: DISABLED\" << std::endl;\n    }\n    \n    std::cout << \"\\n🪙 FTNS Earning:\" << std::endl;\n    if (config.ftns_settings.auto_earn_enabled) {\n        std::cout << \"   Status: ENABLED\" << std::endl;\n        std::cout << \"   Minimum payout: \" << config.ftns_settings.minimum_payout_threshold << \" FTNS\" << std::endl;\n        if (config.compute_settings.enabled) {\n            int monthly = EstimateMonthlyFTNSEarnings(config.compute_settings);\n            std::cout << \"   Estimated monthly: ~\" << monthly << \" FTNS\" << std::endl;\n        }\n    } else {\n        std::cout << \"   Status: DISABLED\" << std::endl;\n    }\n    \n    std::cout << \"\\n🔒 Security: \" << config.security_settings.encryption_level << \" level\" << std::endl;\n    std::cout << \"🌐 Network: Max \" << config.network_settings.max_peer_connections << \" peers\" << std::endl;\n}\n\n// Validation methods\nbool FirstRunSetup::ValidateEmail(const std::string& email) {\n    std::regex email_regex(R\"([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,})\");\n    return std::regex_match(email, email_regex);\n}\n\nbool FirstRunSetup::VerifyInstitutionalAffiliation(const std::string& email, const std::string& domain) {\n    // Mock verification - in real implementation would check against known institutions\n    std::vector<std::string> known_domains = {\n        \"unc.edu\", \"duke.edu\", \"ncsu.edu\", \"mit.edu\", \"stanford.edu\", \n        \"harvard.edu\", \"berkeley.edu\", \"caltech.edu\", \"princeton.edu\"\n    };\n    \n    return std::find(known_domains.begin(), known_domains.end(), domain) != known_domains.end();\n}\n\n// Resource calculation methods\nint FirstRunSetup::EstimateMonthlyFTNSEarnings(const ComputeContribution& compute) {\n    if (!compute.enabled) return 0;\n    \n    int earnings = 0;\n    \n    // Storage contribution\n    earnings += compute.max_storage_gb * 0.3; // 0.3 FTNS per GB per month\n    \n    // Compute contribution (assume 20% utilization)\n    double compute_hours_per_month = (compute.max_cpu_usage_percent / 100.0) * 24 * 30 * 0.2;\n    earnings += static_cast<int>(compute_hours_per_month * 2.0); // 2 FTNS per hour\n    \n    // Bandwidth contribution\n    earnings += compute.max_bandwidth_mbps * 5; // Rough estimate\n    \n    return earnings;\n}\n\nstd::string FirstRunSetup::GetResourceUsageSummary(const ComputeContribution& compute) {\n    std::ostringstream oss;\n    oss << \"\\n📊 Resource Usage Summary:\\n\";\n    oss << \"   CPU: Up to \" << compute.max_cpu_usage_percent << \"% when \" \n        << (compute.contribute_during_idle_only ? \"idle\" : \"active\") << \"\\n\";\n    oss << \"   Storage: \" << compute.max_storage_gb << \" GB for distributed files\\n\";\n    oss << \"   Bandwidth: \" << compute.max_bandwidth_mbps << \" Mbps for P2P sharing\\n\";\n    oss << \"   Restrictions: \" << (compute.exclude_sensitive_files ? \"Exclude sensitive files\" : \"All files\");\n    return oss.str();\n}\n\nbool FirstRunSetup::IsFirstRun() const {\n    return !std::filesystem::exists(config_file_path_);\n}\n\nbool FirstRunSetup::SaveConfiguration(const OnboardingConfig& config) {\n    // Mock JSON save - in real implementation would use JSON library\n    std::ofstream file(config_file_path_);\n    if (!file.is_open()) {\n        return false;\n    }\n    \n    auto now = std::chrono::system_clock::now();\n    auto time_t = std::chrono::system_clock::to_time_t(now);\n    \n    file << \"{\\n\";\n    file << \"  \\\"first_run\\\": false,\\n\";\n    file << \"  \\\"setup_completed\\\": true,\\n\";\n    file << \"  \\\"setup_time\\\": \\\"\" << std::put_time(std::localtime(&time_t), \"%Y-%m-%d %H:%M:%S\") << \"\\\",\\n\";\n    file << \"  \\\"user_profile\\\": {\\n\";\n    file << \"    \\\"name\\\": \\\"\" << config.user_profile.full_name << \"\\\",\\n\";\n    file << \"    \\\"email\\\": \\\"\" << config.user_profile.email << \"\\\",\\n\";\n    file << \"    \\\"institution\\\": \\\"\" << config.user_profile.institution << \"\\\"\\n\";\n    file << \"  },\\n\";\n    file << \"  \\\"compute_enabled\\\": \" << (config.compute_settings.enabled ? \"true\" : \"false\") << \",\\n\";\n    file << \"  \\\"ftns_enabled\\\": \" << (config.ftns_settings.auto_earn_enabled ? \"true\" : \"false\") << \",\\n\";\n    file << \"  \\\"security_level\\\": \\\"\" << config.security_settings.encryption_level << \"\\\"\\n\";\n    file << \"}\\n\";\n    \n    file.close();\n    \n    std::cout << \"✅ Configuration saved to: \" << config_file_path_ << std::endl;\n    return true;\n}\n\n} // namespace lite_browser