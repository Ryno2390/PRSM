"""
NWTN Assumption-Flip Generation Engine
======================================

Implements Phase 2.3 of the Novel Idea Generation Roadmap:
Generates breakthrough candidates by systematically inverting core assumptions.

This engine identifies fundamental assumptions underlying problems and generates
candidates by exploring what happens when those assumptions are inverted,
challenged, or completely removed.

Based on NWTN Novel Idea Generation Roadmap Phase 2.3.
"""

import logging
import asyncio
from typing import Dict, List, Any, Optional, Tuple
from dataclasses import dataclass
from enum import Enum
import re
import random

logger = logging.getLogger(__name__)

class AssumptionType(Enum):
    """Types of assumptions that can be identified and flipped"""
    CAUSAL = "causal"                    # Cause-effect assumptions
    TEMPORAL = "temporal"                # Time-based assumptions  
    STRUCTURAL = "structural"            # Structural organization assumptions
    RESOURCE = "resource"                # Resource availability assumptions
    BEHAVIORAL = "behavioral"            # Human/agent behavior assumptions
    PHYSICAL = "physical"                # Physical law assumptions
    ECONOMIC = "economic"                # Economic principle assumptions
    TECHNOLOGICAL = "technological"      # Technology capability assumptions
    SOCIAL = "social"                    # Social norm assumptions
    LOGICAL = "logical"                  # Logical relationship assumptions

class FlipType(Enum):
    """Types of assumption flipping strategies"""
    DIRECT_INVERSION = "direct_inversion"        # Directly invert the assumption
    REMOVAL = "removal"                          # Remove the assumption entirely
    REVERSAL = "reversal"                        # Reverse the direction/relationship
    EXTREME_AMPLIFICATION = "extreme_amplification"  # Take assumption to extreme
    CONTEXT_SHIFT = "context_shift"              # Change the context/scope
    CONSTRAINT_ELIMINATION = "constraint_elimination"  # Remove constraining assumptions

@dataclass
class IdentifiedAssumption:
    """An assumption identified in the problem or query"""
    assumption_id: str
    assumption_type: AssumptionType
    assumption_text: str              # Original assumption statement
    assumption_basis: str             # Why this is considered an assumption
    confidence_score: float           # How confident we are this is an assumption
    centrality_score: float           # How central this assumption is to the problem
    flip_potential: float             # How much potential flipping this has
    
    # Context
    extracted_from: str               # Where this assumption was found
    domain: str                       # Problem domain
    keywords: List[str]               # Key terms associated with assumption

@dataclass
class AssumptionFlip:
    """A candidate generated by flipping an assumption"""
    flip_id: str
    flip_type: FlipType
    
    # Source assumption
    original_assumption: IdentifiedAssumption
    
    # Flipped candidate
    flipped_assumption: str           # The inverted assumption
    candidate_description: str        # Description of the resulting candidate
    flip_reasoning: str               # Why this flip might be valuable
    
    # Implications
    implications: List[str]           # What this flip implies for the problem
    new_possibilities: List[str]      # New possibilities this opens up
    potential_barriers: List[str]     # What barriers this flip might face
    
    # Assessment scores
    novelty_score: float              # How novel this flip is
    feasibility_score: float          # How feasible this might be
    impact_potential: float           # Potential impact if successful
    paradigm_shift_score: float       # How much this challenges current thinking
    
    # Validation
    testability_criteria: List[str]   # How to test this flipped assumption
    evidence_requirements: List[str]  # What evidence would be needed
    
    # Metadata
    confidence_score: float           # Overall confidence in this flip
    generated_from_papers: List[str]  # Papers that inspired this flip

class AssumptionFlipEngine:
    """
    Generate breakthrough candidates by systematically identifying and inverting 
    fundamental assumptions underlying problems and conventional solutions.
    
    This engine finds what everyone takes for granted, then explores what happens
    when those "obvious" assumptions are challenged, inverted, or eliminated.
    """
    
    def __init__(self):
        self.assumption_patterns = self._initialize_assumption_patterns()
        self.flip_strategies = self._initialize_flip_strategies()
        self.domain_assumptions = self._initialize_domain_assumptions()
        
    def _initialize_assumption_patterns(self) -> Dict[AssumptionType, List[str]]:
        """Initialize patterns for identifying different types of assumptions"""
        return {
            AssumptionType.CAUSAL: [
                r"(.+)\s+causes?\s+(.+)",
                r"(.+)\s+leads?\s+to\s+(.+)",
                r"(.+)\s+results?\s+in\s+(.+)",
                r"because\s+(.+),\s+(.+)",
                r"due\s+to\s+(.+),\s+(.+)",
                r"(.+)\s+is\s+caused\s+by\s+(.+)"
            ],
            
            AssumptionType.TEMPORAL: [
                r"first\s+(.+),\s+then\s+(.+)",
                r"before\s+(.+),\s+(.+)",
                r"after\s+(.+),\s+(.+)",
                r"(.+)\s+precedes\s+(.+)",
                r"(.+)\s+follows\s+(.+)",
                r"(.+)\s+happens\s+before\s+(.+)"
            ],
            
            AssumptionType.RESOURCE: [
                r"requires?\s+(.+)",
                r"needs?\s+(.+)",
                r"limited\s+(.+)",
                r"scarce\s+(.+)",
                r"insufficient\s+(.+)",
                r"lack\s+of\s+(.+)",
                r"more\s+(.+)\s+is\s+needed"
            ],
            
            AssumptionType.BEHAVIORAL: [
                r"people\s+always\s+(.+)",
                r"users\s+will\s+(.+)",
                r"humans\s+tend\s+to\s+(.+)",
                r"customers\s+want\s+(.+)",
                r"agents\s+behave\s+(.+)",
                r"individuals\s+prefer\s+(.+)"
            ],
            
            AssumptionType.TECHNOLOGICAL: [
                r"technology\s+cannot\s+(.+)",
                r"impossible\s+to\s+(.+)",
                r"current\s+systems\s+cannot\s+(.+)",
                r"technically\s+infeasible\s+to\s+(.+)",
                r"beyond\s+current\s+capabilities",
                r"requires\s+advanced\s+technology"
            ],
            
            AssumptionType.ECONOMIC: [
                r"too\s+expensive\s+to\s+(.+)",
                r"cost\s+prohibitive",
                r"economically\s+unfeasible",
                r"market\s+won't\s+accept\s+(.+)",
                r"no\s+business\s+model\s+for\s+(.+)",
                r"price\s+is\s+too\s+high"
            ],
            
            AssumptionType.PHYSICAL: [
                r"physically\s+impossible",
                r"violates\s+(.+)\s+law",
                r"against\s+physics",
                r"thermodynamically\s+impossible",
                r"conservation\s+of\s+(.+)\s+prevents",
                r"fundamental\s+limits\s+prevent"
            ],
            
            AssumptionType.SOCIAL: [
                r"society\s+expects\s+(.+)",
                r"culturally\s+unacceptable",
                r"social\s+norms\s+require\s+(.+)",
                r"people\s+won't\s+accept\s+(.+)",
                r"tradition\s+dictates\s+(.+)",
                r"established\s+practices\s+require"
            ],
            
            AssumptionType.STRUCTURAL: [
                r"must\s+be\s+organized\s+(.+)",
                r"structure\s+requires\s+(.+)",
                r"hierarchy\s+demands\s+(.+)",
                r"architecture\s+needs\s+(.+)",
                r"design\s+must\s+include\s+(.+)",
                r"components\s+must\s+be\s+(.+)"
            ],
            
            AssumptionType.LOGICAL: [
                r"if\s+(.+),\s+then\s+(.+)",
                r"only\s+if\s+(.+)",
                r"necessary\s+condition\s+(.+)",
                r"sufficient\s+condition\s+(.+)",
                r"implies\s+that\s+(.+)",
                r"logically\s+follows\s+that\s+(.+)"
            ]
        }
    
    def _initialize_flip_strategies(self) -> Dict[FlipType, Dict[str, Any]]:
        """Initialize strategies for different types of assumption flipping"""
        return {
            FlipType.DIRECT_INVERSION: {
                "description": "Directly invert the assumption to its opposite",
                "template": "What if the opposite were true: instead of {original}, consider {inverted}",
                "strength": "maximum_contradiction",
                "risk_level": "high"
            },
            
            FlipType.REMOVAL: {
                "description": "Remove the assumption entirely from consideration",
                "template": "What if we completely ignore the assumption that {original} and proceed without it",
                "strength": "assumption_elimination",
                "risk_level": "very_high"
            },
            
            FlipType.REVERSAL: {
                "description": "Reverse the direction or relationship in the assumption",
                "template": "What if we reverse the relationship: instead of {direction_a} → {direction_b}, consider {direction_b} → {direction_a}",
                "strength": "relationship_inversion",
                "risk_level": "medium"
            },
            
            FlipType.EXTREME_AMPLIFICATION: {
                "description": "Take the assumption to an extreme to reveal its limits",
                "template": "What if we take {original} to the absolute extreme: {extreme_version}",
                "strength": "limit_exploration",
                "risk_level": "medium"
            },
            
            FlipType.CONTEXT_SHIFT: {
                "description": "Change the context or scope where the assumption applies",
                "template": "What if {original} only applies in {old_context} but not in {new_context}",
                "strength": "scope_challenge",
                "risk_level": "low"
            },
            
            FlipType.CONSTRAINT_ELIMINATION: {
                "description": "Remove constraining assumptions about what's possible",
                "template": "What if the constraint that {constraint} didn't exist, enabling {new_possibility}",
                "strength": "possibility_expansion",
                "risk_level": "high"
            }
        }
    
    def _initialize_domain_assumptions(self) -> Dict[str, List[str]]:
        """Initialize common assumptions by domain"""
        return {
            "technology": [
                "More computing power is always better",
                "Users want the latest features",
                "Security requires complexity",
                "Bigger systems are more powerful",
                "Automation reduces human involvement"
            ],
            
            "business": [
                "Growth must be continuous",
                "Customers always want lower prices",
                "Competition is always harmful",
                "Profit maximization is the primary goal",
                "Bigger companies are more successful"
            ],
            
            "medical": [
                "More treatment is better treatment",
                "Symptoms should always be eliminated",
                "Prevention requires early intervention",
                "Newer drugs are more effective",
                "Specialization improves outcomes"
            ],
            
            "education": [
                "More information leads to better learning",
                "Students learn best in structured environments",
                "Testing measures learning accurately",
                "Experts should teach novices",
                "Learning requires dedicated time and space"
            ],
            
            "social": [
                "Communication should be direct and clear",
                "Individual responsibility drives success",
                "Competition motivates performance",
                "More choice is always better",
                "Efficiency should be maximized"
            ]
        }
    
    async def generate_assumption_flips(
        self,
        query: str,
        context: Dict[str, Any],
        papers: List[Dict[str, Any]] = None,
        max_flips: int = 5
    ) -> List[AssumptionFlip]:
        """
        Generate assumption flip candidates by identifying and inverting core assumptions
        
        Args:
            query: Research question or problem
            context: Context including breakthrough mode
            papers: Retrieved papers to analyze for assumptions
            max_flips: Maximum number of assumption flips to generate
        
        Returns:
            List of assumption flip candidates
        """
        try:
            logger.info(f"Generating assumption flips for query: {query[:50]}...")
            
            # Identify assumptions in the query and papers
            identified_assumptions = await self._identify_assumptions(query, papers or [])
            
            # Generate flips for the most promising assumptions
            assumption_flips = []
            
            for assumption in identified_assumptions[:max_flips * 2]:  # Generate more than needed
                # Generate multiple flip types for each assumption
                for flip_type in FlipType:
                    flip_candidate = await self._generate_single_assumption_flip(
                        assumption, flip_type, query, context
                    )
                    
                    if flip_candidate:
                        assumption_flips.append(flip_candidate)
                
                if len(assumption_flips) >= max_flips * 3:  # Limit total generation
                    break
            
            # Score and rank flips
            scored_flips = self._score_and_rank_flips(assumption_flips, context)
            
            # Return top flips
            selected_flips = scored_flips[:max_flips]
            
            logger.info(f"Generated {len(selected_flips)} assumption flip candidates")
            return selected_flips
            
        except Exception as e:
            logger.error(f"Failed to generate assumption flips: {e}")
            return []
    
    async def _identify_assumptions(
        self, 
        query: str, 
        papers: List[Dict[str, Any]]
    ) -> List[IdentifiedAssumption]:
        """Identify assumptions in the query and supporting papers"""
        
        assumptions = []
        
        # Extract assumptions from query
        query_assumptions = self._extract_assumptions_from_text(query, "query")
        assumptions.extend(query_assumptions)
        
        # Extract assumptions from papers
        for paper in papers[:5]:  # Limit paper processing
            paper_text = paper.get('content', '') or paper.get('abstract', '')
            if paper_text:
                paper_assumptions = self._extract_assumptions_from_text(
                    paper_text, f"paper: {paper.get('title', 'Unknown')}"
                )
                assumptions.extend(paper_assumptions)
        
        # Add domain-specific assumptions
        domain = self._identify_domain(query)
        domain_assumptions = self._get_domain_assumptions(domain, query)
        assumptions.extend(domain_assumptions)
        
        # Remove duplicates and rank by importance
        unique_assumptions = self._deduplicate_and_rank_assumptions(assumptions)
        
        return unique_assumptions[:10]  # Return top 10 assumptions
    
    def _extract_assumptions_from_text(self, text: str, source: str) -> List[IdentifiedAssumption]:
        """Extract assumptions from a piece of text using pattern matching"""
        
        assumptions = []
        text_lower = text.lower()
        
        for assumption_type, patterns in self.assumption_patterns.items():
            for pattern in patterns:
                matches = re.finditer(pattern, text, re.IGNORECASE)
                
                for match in matches:
                    # Extract the assumption text
                    assumption_text = match.group(0)
                    
                    # Skip very short matches
                    if len(assumption_text) < 10:
                        continue
                    
                    # Create assumption object
                    assumption = IdentifiedAssumption(
                        assumption_id=f"assumption_{hash(assumption_text) % 10000}",
                        assumption_type=assumption_type,
                        assumption_text=assumption_text,
                        assumption_basis=f"Identified via {assumption_type.value} pattern in {source}",
                        confidence_score=self._calculate_assumption_confidence(assumption_text, pattern),
                        centrality_score=self._calculate_centrality_score(assumption_text, text),
                        flip_potential=self._calculate_flip_potential(assumption_text, assumption_type),
                        extracted_from=source,
                        domain=self._identify_domain(text),
                        keywords=self._extract_keywords(assumption_text)
                    )
                    
                    assumptions.append(assumption)
        
        return assumptions
    
    def _calculate_assumption_confidence(self, assumption_text: str, pattern: str) -> float:
        """Calculate confidence that this is actually an assumption"""
        
        # Base confidence from pattern strength
        confidence_patterns = {
            r"(.+)\s+causes?\s+(.+)": 0.9,      # Strong causal language
            r"must\s+be": 0.85,                 # Strong necessity language
            r"always": 0.8,                     # Universal quantifier
            r"impossible": 0.9,                 # Strong constraint language
            r"requires?": 0.7,                  # Dependency language
            r"only\s+if": 0.85                  # Logical constraint
        }
        
        base_confidence = 0.5
        for conf_pattern, score in confidence_patterns.items():
            if re.search(conf_pattern, assumption_text, re.IGNORECASE):
                base_confidence = max(base_confidence, score)
        
        # Adjust for assumption indicators
        assumption_indicators = ["assume", "given", "premise", "suppose", "presume"]
        if any(indicator in assumption_text.lower() for indicator in assumption_indicators):
            base_confidence *= 1.2
        
        # Adjust for certainty language
        certainty_indicators = ["clearly", "obviously", "certainly", "definitely", "undoubtedly"]
        if any(indicator in assumption_text.lower() for indicator in certainty_indicators):
            base_confidence *= 0.8  # High certainty might indicate assumption
        
        return min(1.0, max(0.1, base_confidence))
    
    def _calculate_centrality_score(self, assumption_text: str, full_text: str) -> float:
        """Calculate how central this assumption is to the overall problem"""
        
        # Count keyword overlaps
        assumption_words = set(assumption_text.lower().split())
        full_text_words = set(full_text.lower().split())
        
        overlap_ratio = len(assumption_words & full_text_words) / len(assumption_words) if assumption_words else 0
        
        # Check for position in text (earlier = more central)
        position_ratio = 1.0 - (full_text.find(assumption_text) / len(full_text))
        
        # Combine factors
        centrality = (overlap_ratio * 0.6) + (position_ratio * 0.4)
        
        return min(1.0, max(0.1, centrality))
    
    def _calculate_flip_potential(self, assumption_text: str, assumption_type: AssumptionType) -> float:
        """Calculate the potential value of flipping this assumption"""
        
        # Base potential by assumption type
        type_potential = {
            AssumptionType.CAUSAL: 0.9,         # High potential - causal relationships
            AssumptionType.RESOURCE: 0.8,       # High potential - resource constraints
            AssumptionType.TECHNOLOGICAL: 0.85,  # High potential - tech limitations
            AssumptionType.PHYSICAL: 0.7,       # Medium potential - physical laws hard to flip
            AssumptionType.BEHAVIORAL: 0.75,    # Medium-high potential - behavior assumptions
            AssumptionType.ECONOMIC: 0.8,       # High potential - economic assumptions
            AssumptionType.SOCIAL: 0.7,         # Medium potential - social norms
            AssumptionType.TEMPORAL: 0.6,       # Lower potential - time relationships
            AssumptionType.STRUCTURAL: 0.65,    # Medium potential - structural constraints
            AssumptionType.LOGICAL: 0.55        # Lower potential - logical relationships
        }
        
        base_potential = type_potential.get(assumption_type, 0.6)
        
        # Increase potential for constraint language
        constraint_language = ["cannot", "impossible", "never", "always", "must", "required"]
        if any(word in assumption_text.lower() for word in constraint_language):
            base_potential *= 1.3
        
        # Increase potential for universal quantifiers
        universal_language = ["all", "every", "always", "never", "none"]
        if any(word in assumption_text.lower() for word in universal_language):
            base_potential *= 1.2
        
        return min(1.0, max(0.1, base_potential))
    
    def _identify_domain(self, text: str) -> str:
        """Identify the primary domain of the text"""
        
        domain_keywords = {
            "technology": ["software", "system", "algorithm", "computer", "digital", "AI", "technology"],
            "business": ["market", "customer", "revenue", "profit", "business", "company", "strategy"],
            "medical": ["patient", "treatment", "disease", "medical", "health", "therapy", "clinical"],
            "education": ["student", "learning", "education", "teaching", "school", "knowledge"],
            "social": ["social", "community", "society", "culture", "behavior", "interaction"]
        }
        
        text_lower = text.lower()
        domain_scores = {}
        
        for domain, keywords in domain_keywords.items():
            score = sum(1 for keyword in keywords if keyword in text_lower)
            domain_scores[domain] = score
        
        if domain_scores:
            return max(domain_scores, key=domain_scores.get)
        else:
            return "general"
    
    def _extract_keywords(self, text: str) -> List[str]:
        """Extract key terms from assumption text"""
        
        # Simple keyword extraction
        words = re.findall(r'\b\w+\b', text.lower())
        
        # Filter out common words
        stop_words = {'the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by', 'is', 'are', 'was', 'were', 'be', 'been', 'being', 'have', 'has', 'had', 'do', 'does', 'did', 'will', 'would', 'should', 'could', 'can', 'may', 'might', 'must'}
        
        keywords = [word for word in words if word not in stop_words and len(word) > 3]
        
        return keywords[:5]  # Return top 5 keywords
    
    def _get_domain_assumptions(self, domain: str, query: str) -> List[IdentifiedAssumption]:
        """Get common assumptions for this domain"""
        
        domain_assumptions_list = self.domain_assumptions.get(domain, [])
        assumptions = []
        
        for assumption_text in domain_assumptions_list[:3]:  # Top 3 domain assumptions
            assumption = IdentifiedAssumption(
                assumption_id=f"domain_assumption_{hash(assumption_text) % 10000}",
                assumption_type=AssumptionType.STRUCTURAL,  # Default type for domain assumptions
                assumption_text=assumption_text,
                assumption_basis=f"Common assumption in {domain} domain",
                confidence_score=0.7,  # Medium confidence for domain assumptions
                centrality_score=0.6,  # Medium centrality
                flip_potential=0.8,   # High flip potential for domain assumptions
                extracted_from=f"{domain}_domain_knowledge",
                domain=domain,
                keywords=self._extract_keywords(assumption_text)
            )
            assumptions.append(assumption)
        
        return assumptions
    
    def _deduplicate_and_rank_assumptions(self, assumptions: List[IdentifiedAssumption]) -> List[IdentifiedAssumption]:
        """Remove duplicate assumptions and rank by importance"""
        
        # Simple deduplication by assumption text similarity
        unique_assumptions = []
        seen_texts = set()
        
        for assumption in assumptions:
            # Normalize text for comparison
            normalized_text = re.sub(r'\W+', ' ', assumption.assumption_text.lower()).strip()
            
            if normalized_text not in seen_texts:
                seen_texts.add(normalized_text)
                unique_assumptions.append(assumption)
        
        # Rank by combined score
        def ranking_score(assumption):
            return (assumption.confidence_score * 0.3 + 
                   assumption.centrality_score * 0.3 + 
                   assumption.flip_potential * 0.4)
        
        unique_assumptions.sort(key=ranking_score, reverse=True)
        
        return unique_assumptions
    
    async def _generate_single_assumption_flip(
        self,
        assumption: IdentifiedAssumption,
        flip_type: FlipType,
        query: str,
        context: Dict[str, Any]
    ) -> Optional[AssumptionFlip]:
        """Generate a single assumption flip candidate"""
        
        try:
            # Generate the flipped assumption
            flipped_assumption = self._generate_flipped_assumption(assumption, flip_type)
            
            # Generate candidate description
            candidate_description = self._generate_candidate_description(
                assumption, flipped_assumption, flip_type, query
            )
            
            # Generate flip reasoning
            flip_reasoning = self._generate_flip_reasoning(assumption, flip_type, flipped_assumption)
            
            # Generate implications and possibilities
            implications = self._generate_implications(assumption, flipped_assumption, flip_type)
            new_possibilities = self._generate_new_possibilities(flipped_assumption, query)
            potential_barriers = self._generate_potential_barriers(flipped_assumption, assumption.assumption_type)
            
            # Calculate scores
            novelty_score = self._calculate_novelty_score(assumption, flip_type)
            feasibility_score = self._calculate_feasibility_score(assumption, flip_type)
            impact_potential = self._calculate_impact_potential(assumption, flip_type)
            paradigm_shift_score = self._calculate_paradigm_shift_score(assumption, flip_type)
            
            # Generate validation criteria
            testability_criteria = self._generate_testability_criteria(flipped_assumption)
            evidence_requirements = self._generate_evidence_requirements(flipped_assumption, flip_type)
            
            # Calculate overall confidence
            confidence_score = (novelty_score + feasibility_score + impact_potential) / 3
            
            return AssumptionFlip(
                flip_id=f"flip_{hash(flipped_assumption) % 10000}",
                flip_type=flip_type,
                original_assumption=assumption,
                flipped_assumption=flipped_assumption,
                candidate_description=candidate_description,
                flip_reasoning=flip_reasoning,
                implications=implications,
                new_possibilities=new_possibilities,
                potential_barriers=potential_barriers,
                novelty_score=novelty_score,
                feasibility_score=feasibility_score,
                impact_potential=impact_potential,
                paradigm_shift_score=paradigm_shift_score,
                testability_criteria=testability_criteria,
                evidence_requirements=evidence_requirements,
                confidence_score=confidence_score,
                generated_from_papers=[assumption.extracted_from]
            )
            
        except Exception as e:
            logger.error(f"Failed to generate assumption flip: {e}")
            return None
    
    def _generate_flipped_assumption(self, assumption: IdentifiedAssumption, flip_type: FlipType) -> str:
        """Generate the flipped version of an assumption"""
        
        original = assumption.assumption_text
        
        if flip_type == FlipType.DIRECT_INVERSION:
            # Try to directly invert the assumption
            if "cannot" in original.lower():
                flipped = original.replace("cannot", "can").replace("can't", "can")
            elif "impossible" in original.lower():
                flipped = original.replace("impossible", "possible")
            elif "never" in original.lower():
                flipped = original.replace("never", "always")
            elif "always" in original.lower():
                flipped = original.replace("always", "never")
            elif "must" in original.lower():
                flipped = original.replace("must", "need not")
            elif "requires" in original.lower():
                flipped = original.replace("requires", "does not require")
            else:
                flipped = f"The opposite of: {original}"
        
        elif flip_type == FlipType.REMOVAL:
            flipped = f"Assumption '{original}' is completely ignored and irrelevant"
        
        elif flip_type == FlipType.REVERSAL:
            # Try to reverse causal relationships
            if " causes " in original.lower():
                parts = original.lower().split(" causes ")
                if len(parts) == 2:
                    flipped = f"{parts[1].strip()} causes {parts[0].strip()}"
                else:
                    flipped = f"Reverse relationship: {original}"
            elif " leads to " in original.lower():
                parts = original.lower().split(" leads to ")
                if len(parts) == 2:
                    flipped = f"{parts[1].strip()} leads to {parts[0].strip()}"
                else:
                    flipped = f"Reverse relationship: {original}"
            else:
                flipped = f"Reverse the direction of: {original}"
        
        elif flip_type == FlipType.EXTREME_AMPLIFICATION:
            flipped = f"Take to extreme: {original} → absolute extreme version"
        
        elif flip_type == FlipType.CONTEXT_SHIFT:
            flipped = f"{original} (but only in limited contexts, not universally)"
        
        elif flip_type == FlipType.CONSTRAINT_ELIMINATION:
            if "limited" in original.lower():
                flipped = original.replace("limited", "unlimited")
            elif "constraint" in original.lower():
                flipped = original.replace("constraint", "no constraint on")
            elif "cannot" in original.lower():
                flipped = original.replace("cannot", "can freely")
            else:
                flipped = f"Remove all constraints implied by: {original}"
        
        else:
            flipped = f"Alternative to assumption: {original}"
        
        return flipped
    
    def _generate_candidate_description(
        self, 
        assumption: IdentifiedAssumption,
        flipped_assumption: str,
        flip_type: FlipType,
        query: str
    ) -> str:
        """Generate description of the candidate that results from this flip"""
        
        flip_strategy = self.flip_strategies[flip_type]
        
        description = f"By {flip_strategy['description'].lower()}, this candidate explores: {flipped_assumption}. "
        description += f"This {flip_type.value} approach to '{assumption.assumption_text}' "
        description += f"opens up new solution spaces for the query: {query[:100]}..."
        
        return description
    
    def _generate_flip_reasoning(
        self,
        assumption: IdentifiedAssumption,
        flip_type: FlipType,
        flipped_assumption: str
    ) -> str:
        """Generate reasoning for why this flip might be valuable"""
        
        reasoning_templates = {
            FlipType.DIRECT_INVERSION: [
                "History shows that many 'impossible' things became possible when core assumptions were inverted",
                "Direct inversion often reveals blind spots in conventional thinking",
                "Opposite assumptions can unlock entirely new solution approaches"
            ],
            
            FlipType.REMOVAL: [
                "Removing limiting assumptions entirely can reveal solution paths that were previously invisible",
                "What seems essential may actually be optional constraint",
                "Assumption removal enables thinking outside conventional boundaries"
            ],
            
            FlipType.REVERSAL: [
                "Reversing causal relationships can reveal hidden feedback loops and alternative mechanisms", 
                "What we think is cause may actually be effect",
                "Relationship reversal often exposes overlooked dynamics"
            ],
            
            FlipType.EXTREME_AMPLIFICATION: [
                "Taking assumptions to extremes reveals their breaking points and limitations",
                "Extreme scenarios often clarify what is truly essential versus optional",
                "Amplification can expose weaknesses in fundamental reasoning"
            ],
            
            FlipType.CONTEXT_SHIFT: [
                "Context-dependent assumptions may not apply universally",
                "Shifting scope can reveal where assumptions break down",
                "Different contexts may require different fundamental premises"
            ],
            
            FlipType.CONSTRAINT_ELIMINATION: [
                "Many constraints are artificially imposed rather than truly fundamental",
                "Eliminating constraints can reveal previously impossible solution paths", 
                "Resource limitations may be more flexible than assumed"
            ]
        }
        
        templates = reasoning_templates.get(flip_type, reasoning_templates[FlipType.DIRECT_INVERSION])
        base_reasoning = random.choice(templates)
        
        return f"{base_reasoning}. In this case, {flipped_assumption[:100]}... challenges the fundamental premise that {assumption.assumption_text[:50]}..."
    
    def _generate_implications(
        self,
        assumption: IdentifiedAssumption,
        flipped_assumption: str,
        flip_type: FlipType
    ) -> List[str]:
        """Generate implications of this assumption flip"""
        
        implications = []
        
        # General implications based on flip type
        if flip_type == FlipType.DIRECT_INVERSION:
            implications.extend([
                "Complete reversal of conventional solution approaches",
                "Existing methods may become counterproductive",
                "New success metrics and evaluation criteria needed"
            ])
        
        elif flip_type == FlipType.REMOVAL:
            implications.extend([
                "Solutions no longer constrained by this assumption",
                "Previously impossible approaches become viable", 
                "Resource allocation priorities may shift dramatically"
            ])
        
        elif flip_type == FlipType.CONSTRAINT_ELIMINATION:
            implications.extend([
                "Unlimited exploration of previously constrained solution space",
                "Traditional trade-offs may no longer apply",
                "Scalability limitations removed"
            ])
        
        # Domain-specific implications
        if assumption.domain == "technology":
            implications.append("Technological solutions may follow completely different architectures")
        elif assumption.domain == "business":
            implications.append("Business models and value propositions may be fundamentally different")
        elif assumption.domain == "medical":
            implications.append("Treatment paradigms and patient care approaches may be revolutionized")
        
        return implications[:4]  # Limit to top 4 implications
    
    def _generate_new_possibilities(self, flipped_assumption: str, query: str) -> List[str]:
        """Generate new possibilities this flip opens up"""
        
        possibilities = [
            "Novel solution approaches that were previously unconsidered",
            "Integration of methods from completely different domains",
            "Resource utilization in ways that weren't possible before",
            "Paradigm shift in how the problem is fundamentally understood"
        ]
        
        # Add query-specific possibilities
        if "efficiency" in query.lower():
            possibilities.append("Efficiency gains through completely different optimization criteria")
        
        if "innovation" in query.lower():
            possibilities.append("Innovation through assumption-challenging rather than assumption-accepting approaches")
        
        if "problem" in query.lower():
            possibilities.append("Reframe the problem definition itself rather than just solving it")
        
        return possibilities[:4]  # Limit to top 4 possibilities
    
    def _generate_potential_barriers(self, flipped_assumption: str, assumption_type: AssumptionType) -> List[str]:
        """Generate potential barriers to this assumption flip"""
        
        barriers = []
        
        # General barriers
        barriers.extend([
            "Strong resistance from established practices and stakeholders",
            "Lack of empirical evidence for the flipped assumption",
            "Potential unintended consequences of assumption change"
        ])
        
        # Type-specific barriers
        if assumption_type == AssumptionType.PHYSICAL:
            barriers.append("May conflict with fundamental physical laws")
        elif assumption_type == AssumptionType.ECONOMIC:
            barriers.append("Economic feasibility may be challenging")
        elif assumption_type == AssumptionType.SOCIAL:
            barriers.append("Social acceptance and cultural resistance")
        elif assumption_type == AssumptionType.TECHNOLOGICAL:
            barriers.append("Technology limitations may still apply")
        
        return barriers[:3]  # Limit to top 3 barriers
    
    def _calculate_novelty_score(self, assumption: IdentifiedAssumption, flip_type: FlipType) -> float:
        """Calculate novelty score for the assumption flip"""
        
        # Base novelty by flip type (more extreme flips = higher novelty)
        flip_novelty = {
            FlipType.REMOVAL: 1.0,               # Highest novelty
            FlipType.DIRECT_INVERSION: 0.9,
            FlipType.CONSTRAINT_ELIMINATION: 0.85,
            FlipType.REVERSAL: 0.7,
            FlipType.EXTREME_AMPLIFICATION: 0.75,
            FlipType.CONTEXT_SHIFT: 0.5          # Lowest novelty
        }
        
        base_novelty = flip_novelty.get(flip_type, 0.7)
        
        # Adjust for assumption centrality (more central = higher novelty when flipped)
        centrality_bonus = assumption.centrality_score * 0.3
        
        # Adjust for assumption confidence (higher confidence = higher novelty when flipped)
        confidence_bonus = assumption.confidence_score * 0.2
        
        total_novelty = base_novelty + centrality_bonus + confidence_bonus
        
        return min(1.0, max(0.1, total_novelty))
    
    def _calculate_feasibility_score(self, assumption: IdentifiedAssumption, flip_type: FlipType) -> float:
        """Calculate feasibility score for the assumption flip"""
        
        # Base feasibility by flip type (less extreme = higher feasibility)
        flip_feasibility = {
            FlipType.CONTEXT_SHIFT: 0.8,        # Highest feasibility
            FlipType.EXTREME_AMPLIFICATION: 0.7,
            FlipType.REVERSAL: 0.6,
            FlipType.DIRECT_INVERSION: 0.5,
            FlipType.CONSTRAINT_ELIMINATION: 0.4,
            FlipType.REMOVAL: 0.3                # Lowest feasibility
        }
        
        base_feasibility = flip_feasibility.get(flip_type, 0.5)
        
        # Adjust for assumption type (some types are easier to flip)
        type_feasibility = {
            AssumptionType.BEHAVIORAL: 0.8,     # Human behavior assumptions easier to flip
            AssumptionType.SOCIAL: 0.7,
            AssumptionType.ECONOMIC: 0.6,
            AssumptionType.TECHNOLOGICAL: 0.6,
            AssumptionType.STRUCTURAL: 0.5,
            AssumptionType.PHYSICAL: 0.3,       # Physical laws harder to flip
            AssumptionType.LOGICAL: 0.4
        }
        
        type_adjustment = type_feasibility.get(assumption.assumption_type, 0.5)
        
        # Combine scores
        feasibility = (base_feasibility * 0.7) + (type_adjustment * 0.3)
        
        return min(1.0, max(0.1, feasibility))
    
    def _calculate_impact_potential(self, assumption: IdentifiedAssumption, flip_type: FlipType) -> float:
        """Calculate potential impact of the assumption flip"""
        
        # Higher centrality and flip potential = higher impact
        impact_base = (assumption.centrality_score + assumption.flip_potential) / 2
        
        # Adjust for flip type intensity
        flip_intensity = {
            FlipType.REMOVAL: 1.0,               # Maximum impact
            FlipType.DIRECT_INVERSION: 0.9,
            FlipType.CONSTRAINT_ELIMINATION: 0.85,
            FlipType.REVERSAL: 0.7,
            FlipType.EXTREME_AMPLIFICATION: 0.6,
            FlipType.CONTEXT_SHIFT: 0.4          # Minimum impact
        }
        
        intensity_factor = flip_intensity.get(flip_type, 0.7)
        
        impact = impact_base * intensity_factor
        
        return min(1.0, max(0.1, impact))
    
    def _calculate_paradigm_shift_score(self, assumption: IdentifiedAssumption, flip_type: FlipType) -> float:
        """Calculate how much this flip would shift current paradigms"""
        
        # Base paradigm shift by assumption type
        type_paradigm_shift = {
            AssumptionType.CAUSAL: 0.9,         # Causal assumptions create big paradigm shifts
            AssumptionType.PHYSICAL: 0.85,      # Physical assumptions if flippable
            AssumptionType.LOGICAL: 0.8,        # Logical assumptions
            AssumptionType.STRUCTURAL: 0.7,
            AssumptionType.TECHNOLOGICAL: 0.65,
            AssumptionType.ECONOMIC: 0.6,
            AssumptionType.BEHAVIORAL: 0.5,
            AssumptionType.SOCIAL: 0.45
        }
        
        base_shift = type_paradigm_shift.get(assumption.assumption_type, 0.6)
        
        # Adjust for flip type intensity
        if flip_type in [FlipType.REMOVAL, FlipType.DIRECT_INVERSION]:
            base_shift *= 1.3
        elif flip_type in [FlipType.CONSTRAINT_ELIMINATION, FlipType.REVERSAL]:
            base_shift *= 1.1
        
        # Adjust for assumption confidence (higher confidence = bigger shift when flipped)
        confidence_multiplier = 0.8 + (assumption.confidence_score * 0.4)
        
        paradigm_shift = base_shift * confidence_multiplier
        
        return min(1.0, max(0.1, paradigm_shift))
    
    def _generate_testability_criteria(self, flipped_assumption: str) -> List[str]:
        """Generate criteria for testing the flipped assumption"""
        
        criteria = [
            "Design controlled experiments that isolate the flipped assumption",
            "Measure outcomes under both original and flipped assumption conditions", 
            "Identify observable predictions that differ between assumptions",
            "Test edge cases where assumption flip should show strongest effects"
        ]
        
        # Add specific criteria based on content
        if "efficiency" in flipped_assumption.lower():
            criteria.append("Measure efficiency metrics under flipped assumption conditions")
        
        if "behavior" in flipped_assumption.lower():
            criteria.append("Conduct behavioral studies comparing assumption scenarios")
        
        if "performance" in flipped_assumption.lower():
            criteria.append("Benchmark performance under flipped vs original assumptions")
        
        return criteria[:4]  # Limit to top 4 criteria
    
    def _generate_evidence_requirements(self, flipped_assumption: str, flip_type: FlipType) -> List[str]:
        """Generate evidence requirements for validating the flipped assumption"""
        
        evidence = [
            "Statistical evidence showing improved outcomes under flipped assumption",
            "Case studies demonstrating successful application of flipped approach",
            "Theoretical analysis validating the flipped assumption framework"
        ]
        
        # Add flip-type specific evidence requirements
        if flip_type == FlipType.DIRECT_INVERSION:
            evidence.append("Direct comparative studies between original and inverted approaches")
        elif flip_type == FlipType.REMOVAL:
            evidence.append("Evidence that removing the assumption doesn't cause predicted negative outcomes")
        elif flip_type == FlipType.CONSTRAINT_ELIMINATION:
            evidence.append("Proof that constraint removal enables previously impossible solutions")
        
        return evidence[:4]  # Limit to top 4 evidence requirements
    
    def _score_and_rank_flips(self, flips: List[AssumptionFlip], context: Dict[str, Any]) -> List[AssumptionFlip]:
        """Score and rank assumption flips by overall promise"""
        
        # Calculate combined score for each flip
        for flip in flips:
            # Weighted combination of scores
            combined_score = (
                flip.novelty_score * 0.3 +
                flip.impact_potential * 0.3 +
                flip.feasibility_score * 0.2 +
                flip.paradigm_shift_score * 0.2
            )
            
            # Adjust for breakthrough mode
            breakthrough_mode = context.get("breakthrough_mode", "balanced")
            if breakthrough_mode == "revolutionary":
                # Revolutionary mode prefers higher novelty and paradigm shift
                combined_score = (
                    flip.novelty_score * 0.35 +
                    flip.paradigm_shift_score * 0.35 +
                    flip.impact_potential * 0.2 +
                    flip.feasibility_score * 0.1
                )
            elif breakthrough_mode == "conservative":
                # Conservative mode prefers higher feasibility
                combined_score = (
                    flip.feasibility_score * 0.4 +
                    flip.impact_potential * 0.3 +
                    flip.novelty_score * 0.2 +
                    flip.paradigm_shift_score * 0.1
                )
            
            # Update confidence score with combined score
            flip.confidence_score = combined_score
        
        # Sort by combined score
        flips.sort(key=lambda f: f.confidence_score, reverse=True)
        
        return flips

# Global instance
assumption_flip_engine = AssumptionFlipEngine()

async def generate_assumption_flips(
    query: str,
    context: Dict[str, Any],
    papers: List[Dict[str, Any]] = None,
    max_flips: int = 5
) -> List[AssumptionFlip]:
    """Convenience function to generate assumption flips"""
    return await assumption_flip_engine.generate_assumption_flips(
        query, context, papers, max_flips
    )